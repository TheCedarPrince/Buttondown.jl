# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct SubscribersApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `SubscribersApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ SubscribersApi }) = "http://localhost"

const _returntypes_create_a_new_subscriber_SubscribersApi = Dict{Regex,Type}(
    Regex("^" * replace("201", "x"=>".") * "\$") => Subscriber,
    Regex("^" * replace("400", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_create_a_new_subscriber(_api::SubscribersApi; subscriber=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_create_a_new_subscriber_SubscribersApi, "/v1/subscribers", [], subscriber)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", "application/x-www-form-urlencoded", "multipart/form-data", ] : [_mediaType])
    return _ctx
end

@doc raw"""If Buttondown cannot create a new subscriber with the email address you've provided, there are a few likely reasons why. They're enumerated below: - _A subscriber with that email has already been unsubscribed_. - _That email address (justin@gmail.com) is already subscribed_. - _That email address (justin@gmail.com) is already subscribed, but has not confirmed their email_. - _That email address (justin@gmail.com) is already subscribed, but has not provided payment_. 

Params:
- subscriber::Subscriber

Return: Subscriber, OpenAPI.Clients.ApiResponse
"""
function create_a_new_subscriber(_api::SubscribersApi; subscriber=nothing, _mediaType=nothing)
    _ctx = _oacinternal_create_a_new_subscriber(_api; subscriber=subscriber, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function create_a_new_subscriber(_api::SubscribersApi, response_stream::Channel; subscriber=nothing, _mediaType=nothing)
    _ctx = _oacinternal_create_a_new_subscriber(_api; subscriber=subscriber, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_delete_a_subscriber_SubscribersApi = Dict{Regex,Type}(
    Regex("^" * replace("204", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_delete_a_subscriber(_api::SubscribersApi, id::String; ordering=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "DELETE", _returntypes_delete_a_subscriber_SubscribersApi, "/v1/subscribers/{id}", [])
    OpenAPI.Clients.set_param(_ctx.path, "id", id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "ordering", ordering)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, [])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Params:
- id::String (required)
- ordering::String

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function delete_a_subscriber(_api::SubscribersApi, id::String; ordering=nothing, _mediaType=nothing)
    _ctx = _oacinternal_delete_a_subscriber(_api, id; ordering=ordering, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function delete_a_subscriber(_api::SubscribersApi, response_stream::Channel, id::String; ordering=nothing, _mediaType=nothing)
    _ctx = _oacinternal_delete_a_subscriber(_api, id; ordering=ordering, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_list_all_subscribers_SubscribersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => ListAllSubscribers200Response,
)

function _oacinternal_list_all_subscribers(_api::SubscribersApi; type=nothing, tag=nothing, email=nothing, page=nothing, ordering=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_list_all_subscribers_SubscribersApi, "/v1/subscribers", [])
    OpenAPI.Clients.set_param(_ctx.query, "type", type)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "tag", tag)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "email", email)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "page", page)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "ordering", ordering)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""It's worth noting that the various parametric options in this API work in tandem; you can, for instance, filter down your results to all \"unpaid\" subscribers matching a certain tag.

Params:
- type::String
- tag::String
- email::String
- page::Int64
- ordering::String

Return: ListAllSubscribers200Response, OpenAPI.Clients.ApiResponse
"""
function list_all_subscribers(_api::SubscribersApi; type=nothing, tag=nothing, email=nothing, page=nothing, ordering=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_all_subscribers(_api; type=type, tag=tag, email=email, page=page, ordering=ordering, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function list_all_subscribers(_api::SubscribersApi, response_stream::Channel; type=nothing, tag=nothing, email=nothing, page=nothing, ordering=nothing, _mediaType=nothing)
    _ctx = _oacinternal_list_all_subscribers(_api; type=type, tag=tag, email=email, page=page, ordering=ordering, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_partially_update_an_existing_subscriber_SubscribersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Subscriber,
)

function _oacinternal_partially_update_an_existing_subscriber(_api::SubscribersApi, id::String; ordering=nothing, subscriber=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PATCH", _returntypes_partially_update_an_existing_subscriber_SubscribersApi, "/v1/subscribers/{id}", [], subscriber)
    OpenAPI.Clients.set_param(_ctx.path, "id", id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "ordering", ordering)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", "application/x-www-form-urlencoded", "multipart/form-data", ] : [_mediaType])
    return _ctx
end

@doc raw"""Params:
- id::String (required)
- ordering::String
- subscriber::Subscriber

Return: Subscriber, OpenAPI.Clients.ApiResponse
"""
function partially_update_an_existing_subscriber(_api::SubscribersApi, id::String; ordering=nothing, subscriber=nothing, _mediaType=nothing)
    _ctx = _oacinternal_partially_update_an_existing_subscriber(_api, id; ordering=ordering, subscriber=subscriber, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function partially_update_an_existing_subscriber(_api::SubscribersApi, response_stream::Channel, id::String; ordering=nothing, subscriber=nothing, _mediaType=nothing)
    _ctx = _oacinternal_partially_update_an_existing_subscriber(_api, id; ordering=ordering, subscriber=subscriber, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_retrieve_an_existing_subscriber_SubscribersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Subscriber,
)

function _oacinternal_retrieve_an_existing_subscriber(_api::SubscribersApi, id::String; ordering=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_retrieve_an_existing_subscriber_SubscribersApi, "/v1/subscribers/{id}", [])
    OpenAPI.Clients.set_param(_ctx.path, "id", id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "ordering", ordering)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Params:
- id::String (required)
- ordering::String

Return: Subscriber, OpenAPI.Clients.ApiResponse
"""
function retrieve_an_existing_subscriber(_api::SubscribersApi, id::String; ordering=nothing, _mediaType=nothing)
    _ctx = _oacinternal_retrieve_an_existing_subscriber(_api, id; ordering=ordering, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function retrieve_an_existing_subscriber(_api::SubscribersApi, response_stream::Channel, id::String; ordering=nothing, _mediaType=nothing)
    _ctx = _oacinternal_retrieve_an_existing_subscriber(_api, id; ordering=ordering, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_send_an_email_to_an_active_subscriber_SubscribersApi = Dict{Regex,Type}(
    Regex("^" * replace("201", "x"=>".") * "\$") => Any,
)

function _oacinternal_send_an_email_to_an_active_subscriber(_api::SubscribersApi, id::String, email_id::String; body=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_send_an_email_to_an_active_subscriber_SubscribersApi, "/v1/subscribers/{id}/emails/{email_id}", [], body)
    OpenAPI.Clients.set_param(_ctx.path, "id", id)  # type String
    OpenAPI.Clients.set_param(_ctx.path, "email_id", email_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", "application/x-www-form-urlencoded", "multipart/form-data", ] : [_mediaType])
    return _ctx
end

@doc raw"""This endpoint is currently in closed beta. If you're interested in using it, please [email me](mailto:justin@buttondown.email) to tell me more about your use case!

Params:
- id::String (required)
- email_id::String (required)
- body::Any

Return: Any, OpenAPI.Clients.ApiResponse
"""
function send_an_email_to_an_active_subscriber(_api::SubscribersApi, id::String, email_id::String; body=nothing, _mediaType=nothing)
    _ctx = _oacinternal_send_an_email_to_an_active_subscriber(_api, id, email_id; body=body, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function send_an_email_to_an_active_subscriber(_api::SubscribersApi, response_stream::Channel, id::String, email_id::String; body=nothing, _mediaType=nothing)
    _ctx = _oacinternal_send_an_email_to_an_active_subscriber(_api, id, email_id; body=body, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_an_existing_subscriber_SubscribersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Subscriber,
)

function _oacinternal_update_an_existing_subscriber(_api::SubscribersApi, id::String; ordering=nothing, subscriber=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_update_an_existing_subscriber_SubscribersApi, "/v1/subscribers/{id}", [], subscriber)
    OpenAPI.Clients.set_param(_ctx.path, "id", id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "ordering", ordering)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", "application/x-www-form-urlencoded", "multipart/form-data", ] : [_mediaType])
    return _ctx
end

@doc raw"""Params:
- id::String (required)
- ordering::String
- subscriber::Subscriber

Return: Subscriber, OpenAPI.Clients.ApiResponse
"""
function update_an_existing_subscriber(_api::SubscribersApi, id::String; ordering=nothing, subscriber=nothing, _mediaType=nothing)
    _ctx = _oacinternal_update_an_existing_subscriber(_api, id; ordering=ordering, subscriber=subscriber, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_an_existing_subscriber(_api::SubscribersApi, response_stream::Channel, id::String; ordering=nothing, subscriber=nothing, _mediaType=nothing)
    _ctx = _oacinternal_update_an_existing_subscriber(_api, id; ordering=ordering, subscriber=subscriber, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export create_a_new_subscriber
export delete_a_subscriber
export list_all_subscribers
export partially_update_an_existing_subscriber
export retrieve_an_existing_subscriber
export send_an_email_to_an_active_subscriber
export update_an_existing_subscriber
